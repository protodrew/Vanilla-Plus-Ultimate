#version 150 core
#define MC_GL_NV_vertex_buffer_unified_memory

#define MC_GL_EXT_texture_filter_anisotropic

#define MC_GL_KHR_shader_subgroup

#define MC_GL_NV_gpu_program_fp64

#define MC_GL_ARB_timer_query

#define MC_GL_NV_register_combiners

#define MC_GL_NV_half_float

#define MC_GL_ARB_framebuffer_sRGB

#define MC_GL_ARB_texture_gather

#define MC_GL_NV_geometry_shader4

#define MC_GL_EXT_texture_edge_clamp

#define MC_GL_NV_multisample_filter_hint

#define MC_GL_VENDOR_NVIDIA

#define MC_GL_ARB_texture_rgb10_a2ui

#define MC_GL_ARB_transpose_matrix

#define MC_GL_ARB_texture_stencil8

#define MC_GL_NV_framebuffer_multisample_coverage

#define MC_GL_NV_conditional_render

#define MC_GL_NV_copy_image

#define MC_GL_ARB_vertex_buffer_object

#define MC_GL_EXT_direct_state_access

#define MC_GL_EXT_texture_object

#define MC_GL_ARB_window_pos

#define MC_GL_NV_gpu_shader5

#define MC_GL_KHR_parallel_shader_compile

#define MC_OS_LINUX

#define MC_GL_ARB_point_parameters

#define MC_GL_ARB_draw_buffers_blend

#define MC_GL_EXT_semaphore

#define MC_GL_EXT_vertex_array_bgra

#define MC_GL_EXT_blend_func_separate

#define MC_GL_EXT_texture_compression_dxt1

#define MC_GL_EXT_compiled_vertex_array

#define MC_GL_EXT_blend_minmax

#define MC_GL_EXT_pixel_buffer_object

#define MC_GL_NV_shader_atomic_float64

#define MC_GL_NV_clip_space_w_scaling

#define MC_GL_NV_conservative_raster_pre_snap_triangles

#define MC_GL_ARB_shader_image_size

#define MC_GL_NV_texgen_reflection

#define MC_GL_ARB_sparse_texture2

#define MC_GL_ARB_bindless_texture

#define MC_GL_ARB_texture_buffer_object_rgb32

#define MC_GL_ARB_get_program_binary

#define MC_GL_NV_shader_subgroup_partitioned

#define MC_GL_EXTX_framebuffer_mixed_formats

#define MC_GL_EXT_shader_image_load_formatted

#define MC_GL_ARB_texture_rectangle

#define MC_GL_ARB_shading_language_100

#define MC_GL_ARB_debug_output

#define MC_GL_NV_shader_atomic_fp16_vector

#define MC_GL_NV_packed_depth_stencil

#define MC_GL_NV_conservative_raster

#define MC_GL_ARB_vertex_program

#define MC_GL_ARB_fragment_coord_conventions

#define MC_GL_ARB_compute_variable_group_size

#define MC_GL_EXT_framebuffer_blit

#define MC_GL_EXT_fog_coord

#define MC_GL_ARB_shading_language_packing

#define MC_GL_ARB_texture_filter_anisotropic

#define MC_GL_NVX_blend_equation_advanced_multi_draw_buffers

#define MC_GL_EXT_packed_float

#define MC_GL_NV_fragment_program_option

#define MC_GL_VERSION 320

#define MC_GL_ARB_texture_barrier

#define MC_VERSION 11701

#define MC_GL_ARB_buffer_storage

#define MC_GL_NV_blend_square

#define MC_GL_EXT_shadow_funcs

#define MC_GL_NV_copy_depth_to_color

#define MC_GL_EXT_multiview_texture_multisample

#define MC_GL_ARB_shader_precision

#define MC_GL_ARB_shader_atomic_counter_ops

#define MC_GL_EXT_texture_env_combine

#define MC_GL_EXT_point_parameters

#define MC_GL_ARB_texture_border_clamp

#define MC_GL_ARB_sparse_buffer

#define MC_GL_ARB_vertex_attrib_64bit

#define MC_GL_NV_fill_rectangle

#define MC_GL_ARB_cull_distance

#define MC_GL_NV_fragment_shader_interlock

#define MC_GL_ARB_texture_env_add

#define MC_GL_EXT_depth_bounds_test

#define MC_GL_ARB_fragment_layer_viewport

#define MC_GL_ARB_conditional_render_inverted

#define MC_GL_EXT_provoking_vertex

#define MC_GL_NV_vertex_attrib_integer_64bit

#define MC_GL_NV_shader_atomic_float

#define MC_GL_ARB_texture_query_lod

#define MC_GL_NV_stereo_view_rendering

#define MC_GL_ARB_map_buffer_alignment

#define MC_GL_NV_path_rendering

#define MC_GL_ARB_gl_spirv

#define MC_GL_NV_ES1_1_compatibility

#define MC_GL_NV_geometry_shader_passthrough

#define MC_GL_ARB_pipeline_statistics_query

#define MC_GL_EXT_bindable_uniform

#define MC_GL_ARB_shader_image_load_store

#define MC_GL_ARB_separate_shader_objects

#define MC_GL_NV_fog_distance

#define MC_GL_EXT_x11_sync_object

#define MC_GL_NV_shader_buffer_load

#define MC_GL_NV_vertex_program2

#define MC_GL_NV_texture_barrier

#define MC_GL_ARB_vertex_type_2_10_10_10_rev

#define MC_GL_NV_vertex_program3

#define MC_GL_EXT_texture_sRGB_R8

#define MC_GL_ARB_transform_feedback2

#define MC_GL_EXT_texture3D

#define MC_GL_ARB_transform_feedback3

#define MC_GL_ARB_shader_storage_buffer_object

#define MC_GL_ARB_arrays_of_arrays

#define MC_GL_NV_register_combiners2

#define MC_GL_EXT_texture_shadow_lod

#define MC_GL_EXT_packed_depth_stencil

#define MC_GL_ARB_texture_compression_rgtc

#define MC_GL_EXT_geometry_shader4

#define MC_GLSL_VERSION 150

#define MC_GL_NV_texture_rectangle_compressed

#define MC_GL_EXT_separate_specular_color

#define MC_GL_ARB_shader_bit_encoding

#define MC_GL_EXT_draw_instanced

#define MC_GL_EXT_blend_equation_separate

#define MC_GL_ARB_occlusion_query2

#define MC_GL_ARB_half_float_vertex

#define MC_GL_NV_blend_equation_advanced_coherent

#define MC_GL_NV_texture_rectangle

#define MC_GL_EXT_texture_storage

#define MC_GL_ARB_texture_rg

#define MC_GL_EXT_polygon_offset_clamp

#define MC_GL_NV_shader_atomic_counters

#define MC_GL_NV_alpha_to_coverage_dither_control

#define MC_GL_AMD_vertex_shader_layer

#define MC_GL_ARB_shader_texture_lod

#define MC_GL_NV_draw_texture

#define MC_GL_ARB_copy_image

#define MC_GL_ARB_framebuffer_object

#define MC_GL_EXT_raster_multisample

#define MC_GL_EXT_transform_feedback2

#define MC_GL_ARB_color_buffer_float

#define MC_GL_EXT_draw_range_elements

#define MC_GL_NV_compute_program5

#define MC_GL_ARB_texture_mirror_clamp_to_edge

#define MC_GL_ARB_robust_buffer_access_behavior

#define MC_GL_ARB_explicit_uniform_location

#define MC_GL_ARB_ES3_compatibility

#define MC_GL_ARB_half_float_pixel

#define MC_GL_ATI_draw_buffers

#define MC_GL_ARB_shader_ballot

#define MC_GL_NV_fence

#define MC_GL_EXT_separate_shader_objects

#define MC_GL_NV_primitive_restart

#define MC_GL_NV_feature_query

#define MC_GL_NV_transform_feedback2

#define MC_GL_EXT_texture_env_dot3

#define MC_GL_ARB_draw_buffers

#define MC_GL_EXT_import_sync_object

#define MC_GL_NV_texture_shader2

#define MC_GL_ARB_sparse_texture_clamp

#define MC_GL_ARB_compressed_texture_pixel_storage

#define MC_GL_NV_gpu_multicast

#define MC_GL_NV_blend_minmax_factor

#define MC_GL_ARB_texture_env_dot3

#define MC_GL_NV_texture_shader3

#define MC_GL_NV_path_rendering_shared_edge

#define MC_GL_KHR_no_error

#define MC_GL_NV_multisample_coverage

#define MC_GL_EXT_blend_subtract

#define MC_GL_EXT_sparse_texture2

#define MC_GL_NV_ES3_1_compatibility

#define MC_GL_EXT_secondary_color

#define MC_GL_EXT_memory_object

#define MC_GL_EXT_framebuffer_object

#define MC_GL_NV_texture_multisample

#define MC_GL_ARB_spirv_extensions

#define MC_GL_NV_sample_locations

#define MC_GL_ARB_viewport_array

#define MC_GL_ARB_transform_feedback_overflow_query

#define MC_GL_NV_occlusion_query

#define MC_GL_EXT_framebuffer_multisample

#define MC_GL_ARB_seamless_cubemap_per_texture

#define MC_GL_EXT_texture_compression_latc

#define MC_GL_NV_texture_compression_vtc

#define MC_GL_EXT_multiview_timer_query

#define MC_GL_S3_s3tc

#define MC_GL_ARB_vertex_shader

#define MC_GL_KHR_blend_equation_advanced

#define MC_GL_ARB_depth_texture

#define MC_GL_ARB_framebuffer_no_attachments

#define MC_GL_EXT_window_rectangles

#define MC_GL_ARB_shader_viewport_layer_array

#define MC_GL_EXT_texture_mirror_clamp

#define MC_GL_NV_parameter_buffer_object2

#define MC_GL_NV_vertex_program

#define MC_GL_NV_robustness_video_memory_purge

#define MC_GL_ARB_sparse_texture

#define MC_GL_ARB_indirect_parameters

#define MC_GL_EXT_framebuffer_multisample_blit_scaled

#define MC_GL_ARB_invalidate_subdata

#define MC_GL_ARB_texture_swizzle

#define MC_GL_NV_viewport_swizzle

#define MC_GL_EXT_packed_pixels

#define MC_GL_AMD_multi_draw_indirect

#define MC_GL_ARB_polygon_offset_clamp

#define MC_GL_NV_conservative_raster_dilate

#define MC_GL_ARB_seamless_cube_map

#define MC_GL_ARB_geometry_shader4

#define MC_GL_EXT_texture_env_add

#define MC_GL_ARB_stencil_texturing

#define MC_GL_NV_shader_storage_buffer_object

#define MC_GL_ARB_compute_shader

#define MC_GL_ARB_shader_objects

#define MC_GL_NV_gpu_program4_1

#define MC_GL_ARB_multi_draw_indirect

#define MC_GL_ARB_parallel_shader_compile

#define MC_GL_EXT_texture_array

#define MC_GL_ARB_get_texture_sub_image

#define MC_GL_SUN_slice_accum

#define MC_GL_NV_vertex_array_range2

#define MC_GL_NV_gpu_program5_mem_extended

#define MC_GL_EXT_Cg_shader

#define MC_GL_ARB_pixel_buffer_object

#define MC_GL_ARB_tessellation_shader

#define MC_GL_ARB_texture_cube_map_array

#define MC_GL_NV_memory_attachment

#define MC_GL_SGIX_shadow

#define MC_GL_ARB_vertex_array_bgra

#define MC_GL_NV_fragment_coverage_to_color

#define MC_GL_EXT_vertex_attrib_64bit

#define MC_GL_NV_vdpau_interop2

#define MC_GL_NVX_conditional_render

#define MC_GL_NVX_progress_fence

#define MC_GL_EXT_texture_lod_bias

#define MC_GL_EXT_rescale_normal

#define MC_GL_NV_uniform_buffer_unified_memory

#define MC_GL_EXT_memory_object_fd

#define MC_GL_ARB_clear_buffer_object

#define MC_GL_NV_vertex_program1_1

#define MC_GL_NV_query_resource_tag

#define MC_GL_ARB_transform_feedback_instanced

#define MC_GL_ARB_uniform_buffer_object

#define MC_GL_NV_float_buffer

#define MC_GL_KHR_blend_equation_advanced_coherent

#define MC_GL_NV_timeline_semaphore

#define MC_GL_EXT_texture_cube_map

#define MC_GL_ARB_conservative_depth

#define MC_GL_EXT_texture_shared_exponent

#define MC_GL_KHR_robust_buffer_access_behavior

#define MC_GL_IBM_rasterpos_clip

#define MC_GL_ARB_fragment_shader

#define MC_GL_ARB_ES2_compatibility

#define MC_GL_ARB_direct_state_access

#define MC_GL_ARB_draw_instanced

#define MC_GL_EXT_shader_image_load_store

#define MC_GL_ARB_gpu_shader_fp64

#define MC_GL_ARB_texture_buffer_object

#define MC_GL_NV_sample_mask_override_coverage

#define MC_GL_ARB_instanced_arrays

#define MC_GL_ARB_sync

#define MC_GL_ARB_sample_locations

#define MC_GL_NV_point_sprite

#define MC_GL_ARB_base_instance

#define MC_GL_ARB_texture_compression

#define MC_GL_ARB_gpu_shader5

#define MC_GL_NV_viewport_array2

#define MC_GL_EXT_blend_color

#define MC_GL_EXT_gpu_shader4

#define MC_GL_ARB_texture_query_levels

#define MC_GL_EXT_post_depth_coverage

#define MC_GL_EXT_semaphore_fd

#define MC_GL_ARB_texture_non_power_of_two

#define MC_GL_EXT_draw_buffers2

#define MC_GL_EXT_multi_draw_arrays

#define MC_GL_EXT_vertex_array

#define MC_GL_ARB_texture_filter_minmax

#define MC_GL_ARB_texture_buffer_range

#define MC_GL_ARB_shadow

#define MC_GL_ARB_clip_control

#define MC_GL_ARB_ES3_2_compatibility

#define MC_GL_ARB_shading_language_include

#define MC_GL_ARB_texture_compression_bptc

#define MC_GL_ARB_multisample

#define MC_GL_ARB_point_sprite

#define MC_GL_ARB_fragment_program

#define MC_GL_ARB_vertex_array_object

#define MC_GL_OVR_multiview2

#define MC_GL_EXT_texture_compression_rgtc

#define MC_GL_ARB_multitexture

#define MC_GL_OVR_multiview

#define MC_GL_ARB_clear_texture

#define MC_GL_NV_shader_thread_group

#define MC_GL_ARB_shader_subroutine

#define MC_GL_NV_vdpau_interop

#define MC_GL_ARB_query_buffer_object

#define MC_GL_NV_parameter_buffer_object

#define MC_GL_ARB_ES3_1_compatibility

#define MC_GL_ARB_occlusion_query

#define MC_GL_ARB_draw_indirect

#define MC_GL_ARB_texture_view

#define MC_GL_ARB_internalformat_query

#define MC_GL_NV_draw_vulkan_image

#define MC_GL_NV_query_resource

#define MC_GL_EXT_texture_filter_minmax

#define MC_GL_NV_framebuffer_mixed_samples

#define MC_GL_KHR_robustness

#define MC_GL_EXT_texture_sRGB_decode

#define MC_GL_NVX_gpu_memory_info

#define MC_GL_ARB_shading_language_420pack

#define MC_GL_ATI_texture_mirror_once

#define MC_GL_EXT_texture_lod

#define MC_GL_EXT_framebuffer_sRGB

#define MC_GL_NV_memory_object_sparse

#define MC_GL_NV_texture_env_combine4

#define MC_GL_ARB_texture_multisample

#define MC_GL_ARB_sample_shading

#define MC_GL_ARB_draw_elements_base_vertex

#define MC_GL_EXT_gpu_program_parameters

#define MC_GL_KHR_context_flush_control

#define MC_GL_AMD_seamless_cubemap_per_texture

#define MC_GL_ARB_depth_buffer_float

#define MC_GL_NV_internalformat_sample_query

#define MC_GL_ARB_texture_storage

#define MC_GL_ARB_provoking_vertex

#define MC_GL_ARB_vertex_attrib_binding

#define MC_GL_ARB_texture_env_crossbar

#define MC_GL_ARB_fragment_program_shadow

#define MC_GL_NV_shader_atomic_int64

#define MC_GL_NV_explicit_multisample

#define MC_GL_NV_light_max_exponent

#define MC_GL_ARB_texture_float

#define MC_GL_ARB_texture_storage_multisample

#define MC_GL_ARB_blend_func_extended

#define MC_GL_KTX_buffer_region

#define MC_GL_ARB_fragment_shader_interlock

#define MC_GL_ARB_derivative_control

#define MC_GL_NV_blend_equation_advanced

#define MC_GL_ARB_depth_clamp

#define MC_GL_ARB_shader_atomic_counters

#define MC_GL_EXT_bgra

#define MC_GL_ARB_texture_cube_map

#define MC_GL_ARB_shader_texture_image_samples

#define MC_GL_NV_vertex_array_range

#define MC_GL_ARB_shader_draw_parameters

#define MC_GL_ARB_imaging

#define MC_GL_ARB_texture_mirrored_repeat

#define MC_GL_NV_fragment_program

#define MC_GL_NV_depth_buffer_float

#define MC_GL_EXT_texture_buffer_object

#define MC_GL_SGIX_depth_texture

#define MC_GL_ARB_vertex_type_10f_11f_11f_rev

#define MC_GL_EXT_texture_integer

#define MC_GL_EXT_texture_compression_s3tc

#define MC_GL_KHR_debug

#define MC_GL_ARB_robustness

#define MC_GL_EXT_shader_integer_mix

#define MC_GL_NV_fragment_program2

#define MC_GL_NV_pixel_data_range

#define MC_GL_EXT_timer_query

#define MC_GL_ARB_shader_group_vote

#define MC_GL_ARB_internalformat_query2

#define MC_GL_IBM_texture_mirrored_repeat

#define MC_GL_NV_bindless_multi_draw_indirect_count

#define MC_GL_NV_vertex_program2_option

#define MC_GL_ARB_sampler_objects

#define MC_GL_EXT_stencil_wrap

#define MC_GL_ARB_map_buffer_range

#define MC_GL_EXT_texture_swizzle

#define MC_GL_ARB_program_interface_query

#define MC_GL_ARB_enhanced_layouts

#define MC_GL_ARB_texture_env_combine

#define MC_GL_ARB_post_depth_coverage

#define MC_GL_ATI_texture_float

#define MC_GL_NV_command_list

#define MC_GL_SGIS_generate_mipmap

#define MC_GL_ARB_copy_buffer

#define MC_GL_NV_shader_thread_shuffle

#define MC_GL_NV_depth_clamp

#define MC_GL_AMD_vertex_shader_viewport_index

#define MC_GL_NVX_nvenc_interop

#define MC_GL_ARB_multi_bind

#define MC_GL_SGIS_texture_lod

#define MC_GL_ARB_shader_clock

#define MC_GL_EXT_abgr

#define MC_GL_NV_bindless_texture

#define MC_GL_NV_transform_feedback

#define MC_GL_EXT_stencil_two_side

#define MC_GL_NV_bindless_multi_draw_indirect

#define MC_GL_NV_texture_shader

#define MC_GL_RENDERER_GEFORCE

#define MC_GL_ARB_explicit_attrib_location

#define MC_GL_ARB_gpu_shader_int64

#define MC_GL_NV_gpu_program4

#define MC_GL_EXT_texture_sRGB

#define MC_GL_NV_gpu_program5

#define gl_FragData iris_FragData
#define varying in
#define gl_ModelViewProjectionMatrix (gl_ProjectionMatrix * gl_ModelViewMatrix)
#define gl_ModelViewMatrix (iris_ModelViewMat * _iris_internal_translate(iris_ChunkOffset))
#define gl_NormalMatrix mat3(transpose(inverse(gl_ModelViewMatrix)))
#define gl_Color (Color * iris_ColorModulator)
#define gl_ProjectionMatrix iris_ProjMat
#define gl_FogFragCoord iris_FogFragCoord
#define MC_RENDER_QUALITY 1.0
#define MC_SHADOW_QUALITY 1.0
uniform mat4 iris_LightmapTextureMatrix;
uniform mat4 iris_TextureMat;
uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;

struct iris_FogParameters {
    vec4 color;
    float density;
    float start;
    float end;
    float scale;
};

iris_FogParameters iris_Fog = iris_FogParameters(iris_FogColor, iris_FogDensity, iris_FogStart, iris_FogEnd, 1.0 / (iris_FogEnd - iris_FogStart));

#define gl_Fog iris_Fog
in float iris_FogFragCoord;
uniform mat4 iris_ProjMat;
uniform vec4 iris_ColorModulator;
uniform mat4 iris_ModelViewMat;
uniform vec3 iris_ChunkOffset;
mat4 _iris_internal_translate(vec3 offset) {
    // NB: Column-major order
    return mat4(1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                offset.x, offset.y, offset.z, 1.0);
}
out vec4 iris_FragData[8];
vec4 texture2D(sampler2D sampler, vec2 coord) { return texture(sampler, coord); }
vec4 texture2D(sampler2D sampler, vec2 coord, float bias) { return texture(sampler, coord, bias); }
vec4 texture2DLod(sampler2D sampler, vec2 coord, float lod) { return textureLod(sampler, coord, lod); }
vec4 shadow2D(sampler2DShadow sampler, vec3 coord) { return vec4(texture(sampler, coord)); }
vec4 shadow2DLod(sampler2DShadow sampler, vec3 coord, float lod) { return vec4(textureLod(sampler, coord, lod)); }
/* DRAWBUFFERS:02 */ //0=gcolor, 2=gnormal for normals
/*
Sildur's enhanced default, before editing, remember the agreement you've accepted by downloading this shaderpack:
http://www.minecraftforum.net/forums/mapping-and-modding/minecraft-mods/1291396-1-6-4-1-12-1-sildurs-shaders-pc-mac-intel

You are allowed to:
- Modify it for your own personal use only, so don't share it online.

You are not allowed to:
- Rename and/or modify this shaderpack and upload it with your own name on it.
- Provide mirrors by reuploading my shaderpack, if you want to link it, use the link to my thread found above.
- Copy and paste code or even whole files into your "own" shaderpack.
*/
/*---------------------------
/////ADJUSTABLE VARIABLES/////
----------------------------*/							
//#define Colorboost		//Gives default colors a little kick

#define MobsFlashRed

#define Fog					//Toggle default fog.

#define Reflections			//Toggle reflections, also adjust in composite.fsh

#define Shadows				//Also adjust in vertex, SHADOW_MAP_BIAS is also in vertex
#define Colored_Shadows
#define slight 0.55			//[0.50 0.55 0.60 0.65 0.70 0.75 0.80]
#define SHADOW_MAP_BIAS 0.80

#define waterTex			//Toggle water texture

#define nMap 0				//[0 1 2]0=Off 1=Bumpmapping, 2=Parallax, also adjust in vertex
#define POM_RES 32			//Texture / Resourcepack resolution. [32 64 128 256 512 1024 2048]
#define POM_DIST 16.0		//[8.0 16.0 24.0 32.0 40.0 48.0 56.0 64.0]
#define POM_DEPTH 0.30		//[0.10 0.20 0.30 0.40 0.50 0.60 0.70 0.80 0.90 1.0]
//#define draw_bmap			//Draw bmap normals
/*---------------------------
//END OF ADJUSTABLE VARIABLES//
----------------------------*/

//Const
const float ambientOcclusionLevel = 1.0f;
const int	noiseTextureResolution = 128;
const int 	shadowMapResolution = 1024;		//Shadows resolution. [512 1024 2048 3072 4096 8192]
const float shadowDistance = 90.0;			//Draw distance of shadows.[60.0 90.0 120.0 150.0 180.0 210.0]
const float shadowDistanceRenderMul = 1.0f;
const bool 	shadowHardwareFiltering0 = true;
const bool 	shadowHardwareFiltering1 = true;
const float	sunPathRotation	= -40.0f;		//[-10.0 -20.0 -30.0 -40.0f -50.0 -60.0 -70.0 -80.0 -0.15f -0.0 10.0 20.0 30.0 40.0 50.0 60.0 70.0 80.0]
//----------------------------------------------------------------

/* Don't remove me
const int gcolorFormat = RGBA8;
const int gnormalFormat = RGB10_A2;
const int compositeFormat = RGBA8;
-----------------------------------------*/

varying vec4 color;
varying vec3 getShadowpos;
varying vec3 vworldpos;
varying mat3 tbnMatrix;
varying vec2 texcoord;
varying vec2 lmcoord;
varying float NdotL;
varying float iswater;
varying float mat;

uniform sampler2D normals;
uniform sampler2D texture;
uniform sampler2D lightmap;
uniform sampler2DShadow shadowtex0;	//normal shadows
uniform sampler2DShadow shadowtex1; //colored shadows
uniform sampler2D shadowcolor0;
uniform float rainStrength;
uniform vec4 entityColor;
uniform int isEyeInWater;
uniform int entityId;
uniform ivec2 eyeBrightnessSmooth;
uniform vec3 shadowLightPosition;

#ifdef Fog
const int GL_LINEAR = 9729;
const int GL_EXP = 2048;
uniform int fogMode;
#endif

#ifdef Reflections
uniform sampler2D noisetex;
uniform float frameTimeCounter;

mat2 rmatrix(float rad){
	return mat2(vec2(cos(rad), -sin(rad)), vec2(sin(rad), cos(rad)));
}

float calcWaves(vec2 coord){
	vec2 movement = abs(vec2(0.0, -frameTimeCounter * 0.31365*iswater));
		 
	coord *= 0.262144;
	vec2 coord0 = coord * rmatrix(1.0) - movement * 4.0;
		 coord0.y *= 3.0;
	vec2 coord1 = coord * rmatrix(0.5) - movement * 1.5;
		 coord1.y *= 3.0;		 
	vec2 coord2 = coord + movement * 0.5;
		 coord2.y *= 3.0;
	
	float wave = 1.0 - texture2D(noisetex,coord0 * 0.005).x * 10.0;		//big waves
		  wave += texture2D(noisetex,coord1 * 0.010416).x * 7.0;		//small waves
		  wave += sqrt(texture2D(noisetex,coord2 * 0.045).x * 6.5) * 1.33;//noise texture
		  wave *= 0.0157;
	
	return wave;
}

vec3 calcBump(vec2 coord){
	const vec2 deltaPos = vec2(0.25, 0.0);

	float h0 = calcWaves(coord);
	float h1 = calcWaves(coord + deltaPos.xy);
	float h2 = calcWaves(coord - deltaPos.xy);
	float h3 = calcWaves(coord + deltaPos.yx);
	float h4 = calcWaves(coord - deltaPos.yx);

	float xDelta = ((h1-h0)+(h0-h2));
	float yDelta = ((h3-h0)+(h0-h4));

	return vec3(vec2(xDelta,yDelta)*0.45, 0.55); //z = 1.0-0.5
}
#endif

#ifdef Shadows
//Setup emissive lighting
float modlmap = 13.0-lmcoord.s*12.35; 
float torch_lightmap = max(1.5/(modlmap*modlmap)-0.00945,0.0);
vec3 emissiveLight = clamp(vec3(1.25)*torch_lightmap, 0.0, 1.0); //emissive lightmap

float shadowfilter(sampler2DShadow shadowtexture){
	vec2 offset = vec2(0.25, -0.25) / shadowMapResolution;	
	return clamp(dot(vec4(shadow2D(shadowtexture,vec3(getShadowpos.xy + offset.xx, getShadowpos.z)).x,
						  shadow2D(shadowtexture,vec3(getShadowpos.xy + offset.yx, getShadowpos.z)).x,
						  shadow2D(shadowtexture,vec3(getShadowpos.xy + offset.xy, getShadowpos.z)).x,
						  shadow2D(shadowtexture,vec3(getShadowpos.xy + offset.yy, getShadowpos.z)).x),vec4(0.25))*NdotL,0.0,1.0);
}

vec3 calcShadows(vec3 c){
	vec3 finalShading = vec3(0.0);

if(NdotL > 0.0 && rainStrength < 0.9){ //optimization, disable shadows during rain for performance boost
		float shading = shadowfilter(shadowtex0);
	#ifdef Colored_Shadows
		float cshading = shadowfilter(shadowtex1);
		finalShading = texture2D(shadowcolor0, getShadowpos.xy).rgb*(cshading-shading) + shading;
	#else
		finalShading = vec3(shading);
	#endif
	
	//avoid light leaking underground
	finalShading *= mix(max(lmcoord.t-2.0/16.0,0.0)*1.14285714286,1.0,clamp((eyeBrightnessSmooth.y/255.0-2.0/16.)*4.0,0.0,1.0));
	
	finalShading *= (1.0 - rainStrength);		//smoother transition while disabling shadows during rain
	finalShading *= (1.0 - iswater);			//disable shadows on water plane(not fully, 1.0-0.95)
}
	
return c * (1.0+finalShading+emissiveLight) * slight;
}
#endif

#if nMap == 2
#extension GL_ARB_shader_texture_lod : enable
varying float dist;
varying vec3 viewVector;
varying vec4 vtexcoordam; // .st for add, .pq for mul
varying vec2 vtexcoord;
varying float isblock; //mc_Entity.x, hack to only apply pom to blocks
bool block = isblock > 0.0 || isblock < 0.0; //get defined and undefined blocks

uniform ivec2 atlasSize; 
vec2 atlasAspect = vec2(atlasSize.y/float(atlasSize.x), atlasSize.x/float(atlasSize.y));

mat2 dFdxy = mat2(dFdx(vtexcoord.xy*vtexcoordam.pq), dFdy(vtexcoord.xy*vtexcoordam.pq));	
vec4 readNormal(in vec2 coord){
	return texture2DGradARB(normals,fract(coord)*vtexcoordam.pq+vtexcoordam.st,dFdxy[0],dFdxy[1]);
}

vec4 calcPOM(vec4 albedo){
	if(block){	//only apply to blocks else return albedo
	vec2 newCoord = vtexcoord.xy*vtexcoordam.pq+vtexcoordam.st;

	if (dist < POM_DIST && viewVector.z < 0.0 && readNormal(vtexcoord.xy).a < 1.0){
		const float res_stepths = 0.33 * POM_RES;
		vec2 viewCorrection = max(vec2(vtexcoordam.q/vtexcoordam.p*atlasAspect.x,1.0), vec2(1.0,vtexcoordam.p/vtexcoordam.q*atlasAspect.y));
		vec2 pstepth = viewCorrection * viewVector.xy * POM_DEPTH / (-viewVector.z * POM_RES);
		vec2 coord = vtexcoord.xy;
		for (int i= 0; i < res_stepths && (readNormal(coord.xy).a < 1.0-float(i)/POM_RES); ++i) coord += pstepth;
	
		newCoord = fract(coord.xy)*vtexcoordam.pq+vtexcoordam.st;
	}
	albedo = texture2DGradARB(texture, newCoord, dFdxy[0],dFdxy[1])* texture2D(lightmap, lmcoord.st)*color;

	//vec4 specularity = texture2DGradARB(specular, newCoord, dcdx, dcdy);
	vec3 bmap = normalize((texture2DGradARB(normals, newCoord, dFdxy[0],dFdxy[1]).rgb*2.0-1.0) * tbnMatrix);
	float bmaplight = max(dot(bmap, normalize(shadowLightPosition)),0.0);
	#ifdef Shadows
		albedo.rgb *= (1.0 + bmaplight + (1.0 - NdotL)) * 0.5; //normalize lighting with shadows enabled
	#else
		albedo.rgb *= (1.0 + bmaplight) * 0.6;
	#endif
	#ifdef draw_bmap
		if(block)albedo.rgb = bmap;
	#endif
	return albedo;
	} else return albedo;
}
#endif

vec4 encode (vec3 n){
    return vec4(n.xy*inversesqrt(n.z*8.0+8.0) + 0.5, mat/2.0, 1.0);
}

void irisMain() {

	vec4 tex = texture2D(texture, texcoord.st) * texture2D(lightmap, lmcoord.xy) * color;
	vec4 normal = vec4(0.0); //fill the buffer with 0.0 if not needed, improves performance

#if nMap == 1
	vec3 bmap = normalize((texture2D(normals, texcoord.xy).xyz*2.0-1.0) * tbnMatrix);
	float bmaplight = max(dot(bmap, normalize(shadowLightPosition)),0.0);
	#ifdef Shadows
		tex.rgb *= (1.0 + bmaplight + (1.0 - NdotL)) * 0.5; //normalize lighting with shadows enabled
	#else
		tex.rgb *= (1.0 + bmaplight) * 0.6;
	#endif
	#ifdef draw_bmap
		tex.rgb = bmap;
	#endif	
#elif nMap == 2
	tex = calcPOM(tex);
#endif

#ifdef Shadows
	tex.rgb = calcShadows(tex.rgb);
#endif

#ifdef Colorboost
	tex.rgb = pow(tex.rgb*1.20, vec3(1.20));
#endif

#ifdef MobsFlashRed
	tex.rgb = mix(tex.rgb,entityColor.rgb,entityColor.a);
#endif	

#ifdef Reflections	
	vec2 waterpos = (vworldpos.xz - vworldpos.y);
	if(mat > 0.9)normal = vec4(normalize(calcBump(waterpos) * tbnMatrix), 1.0); //mat > 0.9 so that only reflective blocks alter normals, boosts performance by about 30%. mat=reflective
#endif

if(iswater > 0.1){
	if(isEyeInWater > 0.9)tex.a = 0.9;	//improve alpha underwater, default is 1 (opaque)
#ifdef waterTex	
	tex.rgb *= 1.25;					//improve colors on water
#else
	#if MC_VERSION < 11300 		//Add a watercolor fallback for 1.12.2 and below, for some reason color.rgb turns out grey in older versions.
		tex = mix(tex, vec4(0.0, 0.275, 0.525, 0.75), 1.0) * texture2D(lightmap, lmcoord.st);
	#else
		tex.rgb = mix(tex.rgb, color.rgb*0.5, 1.0) * texture2D(lightmap, lmcoord.st).rgb;
	#endif	
#endif
}

/*
	//vec2 modcoord = vec2((vec3(lmcoord.x)*vec3(92.0, 1.0, 0.1)).x, lmcoord.y).xy;

	tex = texture2D(texture, texcoord.st) * color; //overwrite tex
	
	//tex.rgb *= (lmcoord.x > 0.125)? texture2D(lightmap, lmcoord.xy).rgb*vec3(2.0, 1.0, 0.1) : texture2D(lightmap, lmcoord.xy).rgb;
	//tex.rgb *= lmcoord.y+texture2D(lightmap, lmcoord.xx).rgb*vec3(2.0, 1.0, 0.1);		//emissive lightmap for recoloring
	//tex.rgb *= lmcoord.x+texture2D(lightmap, lmcoord.yy).rgb;							//sky lightmap

	//tex.rgb = vec3(lmcoord.x) * vec3(2.0, 1.0, 0.1);		//lmcoord.x = emissive lightmap

	//tex.rgb = vec3(lmcoord.y);		//lmcoord.y = sky lightmap
*/

	//Fix lightning bolts
	if(entityId == 11000.0) tex = texture2D(lightmap, lmcoord.xy)*color;

	gl_FragData[0] = tex;
	gl_FragData[1] = encode(normal.xyz);
	
#ifdef Fog
	if (fogMode == GL_EXP) {
		gl_FragData[0].rgb = mix(gl_FragData[0].rgb, gl_Fog.color.rgb, 1.0 - clamp(exp(-gl_Fog.density * gl_FogFragCoord), 0.0, 1.0));
	} else if (fogMode == GL_LINEAR) {
		gl_FragData[0].rgb = mix(gl_FragData[0].rgb, gl_Fog.color.rgb, clamp((gl_FogFragCoord - gl_Fog.start) * gl_Fog.scale, 0.0, 1.0));
	} else if (isEyeInWater == 1.0 || isEyeInWater == 2.0){
		gl_FragData[0].rgb = mix(gl_FragData[0].rgb, gl_Fog.color.rgb, 1.0 - clamp(exp(-gl_Fog.density * gl_FogFragCoord), 0.0, 1.0));
	}
#endif
}

void main() {
    irisMain();

// alpha test disabled
}
