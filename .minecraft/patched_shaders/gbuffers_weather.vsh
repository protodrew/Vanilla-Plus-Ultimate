#version 150 core
#define MC_GL_NV_vertex_buffer_unified_memory

#define MC_GL_EXT_texture_filter_anisotropic

#define MC_GL_KHR_shader_subgroup

#define MC_GL_NV_gpu_program_fp64

#define MC_GL_ARB_timer_query

#define MC_GL_NV_register_combiners

#define MC_GL_NV_half_float

#define MC_GL_ARB_framebuffer_sRGB

#define MC_GL_ARB_texture_gather

#define MC_GL_NV_geometry_shader4

#define MC_GL_EXT_texture_edge_clamp

#define MC_GL_NV_multisample_filter_hint

#define MC_GL_VENDOR_NVIDIA

#define MC_GL_ARB_texture_rgb10_a2ui

#define MC_GL_ARB_transpose_matrix

#define MC_GL_ARB_texture_stencil8

#define MC_GL_NV_framebuffer_multisample_coverage

#define MC_GL_NV_conditional_render

#define MC_GL_NV_copy_image

#define MC_GL_ARB_vertex_buffer_object

#define MC_GL_EXT_direct_state_access

#define MC_GL_EXT_texture_object

#define MC_GL_ARB_window_pos

#define MC_GL_NV_gpu_shader5

#define MC_GL_KHR_parallel_shader_compile

#define MC_OS_LINUX

#define MC_GL_ARB_point_parameters

#define MC_GL_ARB_draw_buffers_blend

#define MC_GL_EXT_semaphore

#define MC_GL_EXT_vertex_array_bgra

#define MC_GL_EXT_blend_func_separate

#define MC_GL_EXT_texture_compression_dxt1

#define MC_GL_EXT_compiled_vertex_array

#define MC_GL_EXT_blend_minmax

#define MC_GL_EXT_pixel_buffer_object

#define MC_GL_NV_shader_atomic_float64

#define MC_GL_NV_clip_space_w_scaling

#define MC_GL_NV_conservative_raster_pre_snap_triangles

#define MC_GL_ARB_shader_image_size

#define MC_GL_NV_texgen_reflection

#define MC_GL_ARB_sparse_texture2

#define MC_GL_ARB_bindless_texture

#define MC_GL_ARB_texture_buffer_object_rgb32

#define MC_GL_ARB_get_program_binary

#define MC_GL_NV_shader_subgroup_partitioned

#define MC_GL_EXTX_framebuffer_mixed_formats

#define MC_GL_EXT_shader_image_load_formatted

#define MC_GL_ARB_texture_rectangle

#define MC_GL_ARB_shading_language_100

#define MC_GL_ARB_debug_output

#define MC_GL_NV_shader_atomic_fp16_vector

#define MC_GL_NV_packed_depth_stencil

#define MC_GL_NV_conservative_raster

#define MC_GL_ARB_vertex_program

#define MC_GL_ARB_fragment_coord_conventions

#define MC_GL_ARB_compute_variable_group_size

#define MC_GL_EXT_framebuffer_blit

#define MC_GL_EXT_fog_coord

#define MC_GL_ARB_shading_language_packing

#define MC_GL_ARB_texture_filter_anisotropic

#define MC_GL_NVX_blend_equation_advanced_multi_draw_buffers

#define MC_GL_EXT_packed_float

#define MC_GL_NV_fragment_program_option

#define MC_GL_VERSION 320

#define MC_GL_ARB_texture_barrier

#define MC_VERSION 11701

#define MC_GL_ARB_buffer_storage

#define MC_GL_NV_blend_square

#define MC_GL_EXT_shadow_funcs

#define MC_GL_NV_copy_depth_to_color

#define MC_GL_EXT_multiview_texture_multisample

#define MC_GL_ARB_shader_precision

#define MC_GL_ARB_shader_atomic_counter_ops

#define MC_GL_EXT_texture_env_combine

#define MC_GL_EXT_point_parameters

#define MC_GL_ARB_texture_border_clamp

#define MC_GL_ARB_sparse_buffer

#define MC_GL_ARB_vertex_attrib_64bit

#define MC_GL_NV_fill_rectangle

#define MC_GL_ARB_cull_distance

#define MC_GL_NV_fragment_shader_interlock

#define MC_GL_ARB_texture_env_add

#define MC_GL_EXT_depth_bounds_test

#define MC_GL_ARB_fragment_layer_viewport

#define MC_GL_ARB_conditional_render_inverted

#define MC_GL_EXT_provoking_vertex

#define MC_GL_NV_vertex_attrib_integer_64bit

#define MC_GL_NV_shader_atomic_float

#define MC_GL_ARB_texture_query_lod

#define MC_GL_NV_stereo_view_rendering

#define MC_GL_ARB_map_buffer_alignment

#define MC_GL_NV_path_rendering

#define MC_GL_ARB_gl_spirv

#define MC_GL_NV_ES1_1_compatibility

#define MC_GL_NV_geometry_shader_passthrough

#define MC_GL_ARB_pipeline_statistics_query

#define MC_GL_EXT_bindable_uniform

#define MC_GL_ARB_shader_image_load_store

#define MC_GL_ARB_separate_shader_objects

#define MC_GL_NV_fog_distance

#define MC_GL_EXT_x11_sync_object

#define MC_GL_NV_shader_buffer_load

#define MC_GL_NV_vertex_program2

#define MC_GL_NV_texture_barrier

#define MC_GL_ARB_vertex_type_2_10_10_10_rev

#define MC_GL_NV_vertex_program3

#define MC_GL_EXT_texture_sRGB_R8

#define MC_GL_ARB_transform_feedback2

#define MC_GL_EXT_texture3D

#define MC_GL_ARB_transform_feedback3

#define MC_GL_ARB_shader_storage_buffer_object

#define MC_GL_ARB_arrays_of_arrays

#define MC_GL_NV_register_combiners2

#define MC_GL_EXT_texture_shadow_lod

#define MC_GL_EXT_packed_depth_stencil

#define MC_GL_ARB_texture_compression_rgtc

#define MC_GL_EXT_geometry_shader4

#define MC_GLSL_VERSION 150

#define MC_GL_NV_texture_rectangle_compressed

#define MC_GL_EXT_separate_specular_color

#define MC_GL_ARB_shader_bit_encoding

#define MC_GL_EXT_draw_instanced

#define MC_GL_EXT_blend_equation_separate

#define MC_GL_ARB_occlusion_query2

#define MC_GL_ARB_half_float_vertex

#define MC_GL_NV_blend_equation_advanced_coherent

#define MC_GL_NV_texture_rectangle

#define MC_GL_EXT_texture_storage

#define MC_GL_ARB_texture_rg

#define MC_GL_EXT_polygon_offset_clamp

#define MC_GL_NV_shader_atomic_counters

#define MC_GL_NV_alpha_to_coverage_dither_control

#define MC_GL_AMD_vertex_shader_layer

#define MC_GL_ARB_shader_texture_lod

#define MC_GL_NV_draw_texture

#define MC_GL_ARB_copy_image

#define MC_GL_ARB_framebuffer_object

#define MC_GL_EXT_raster_multisample

#define MC_GL_EXT_transform_feedback2

#define MC_GL_ARB_color_buffer_float

#define MC_GL_EXT_draw_range_elements

#define MC_GL_NV_compute_program5

#define MC_GL_ARB_texture_mirror_clamp_to_edge

#define MC_GL_ARB_robust_buffer_access_behavior

#define MC_GL_ARB_explicit_uniform_location

#define MC_GL_ARB_ES3_compatibility

#define MC_GL_ARB_half_float_pixel

#define MC_GL_ATI_draw_buffers

#define MC_GL_ARB_shader_ballot

#define MC_GL_NV_fence

#define MC_GL_EXT_separate_shader_objects

#define MC_GL_NV_primitive_restart

#define MC_GL_NV_feature_query

#define MC_GL_NV_transform_feedback2

#define MC_GL_EXT_texture_env_dot3

#define MC_GL_ARB_draw_buffers

#define MC_GL_EXT_import_sync_object

#define MC_GL_NV_texture_shader2

#define MC_GL_ARB_sparse_texture_clamp

#define MC_GL_ARB_compressed_texture_pixel_storage

#define MC_GL_NV_gpu_multicast

#define MC_GL_NV_blend_minmax_factor

#define MC_GL_ARB_texture_env_dot3

#define MC_GL_NV_texture_shader3

#define MC_GL_NV_path_rendering_shared_edge

#define MC_GL_KHR_no_error

#define MC_GL_NV_multisample_coverage

#define MC_GL_EXT_blend_subtract

#define MC_GL_EXT_sparse_texture2

#define MC_GL_NV_ES3_1_compatibility

#define MC_GL_EXT_secondary_color

#define MC_GL_EXT_memory_object

#define MC_GL_EXT_framebuffer_object

#define MC_GL_NV_texture_multisample

#define MC_GL_ARB_spirv_extensions

#define MC_GL_NV_sample_locations

#define MC_GL_ARB_viewport_array

#define MC_GL_ARB_transform_feedback_overflow_query

#define MC_GL_NV_occlusion_query

#define MC_GL_EXT_framebuffer_multisample

#define MC_GL_ARB_seamless_cubemap_per_texture

#define MC_GL_EXT_texture_compression_latc

#define MC_GL_NV_texture_compression_vtc

#define MC_GL_EXT_multiview_timer_query

#define MC_GL_S3_s3tc

#define MC_GL_ARB_vertex_shader

#define MC_GL_KHR_blend_equation_advanced

#define MC_GL_ARB_depth_texture

#define MC_GL_ARB_framebuffer_no_attachments

#define MC_GL_EXT_window_rectangles

#define MC_GL_ARB_shader_viewport_layer_array

#define MC_GL_EXT_texture_mirror_clamp

#define MC_GL_NV_parameter_buffer_object2

#define MC_GL_NV_vertex_program

#define MC_GL_NV_robustness_video_memory_purge

#define MC_GL_ARB_sparse_texture

#define MC_GL_ARB_indirect_parameters

#define MC_GL_EXT_framebuffer_multisample_blit_scaled

#define MC_GL_ARB_invalidate_subdata

#define MC_GL_ARB_texture_swizzle

#define MC_GL_NV_viewport_swizzle

#define MC_GL_EXT_packed_pixels

#define MC_GL_AMD_multi_draw_indirect

#define MC_GL_ARB_polygon_offset_clamp

#define MC_GL_NV_conservative_raster_dilate

#define MC_GL_ARB_seamless_cube_map

#define MC_GL_ARB_geometry_shader4

#define MC_GL_EXT_texture_env_add

#define MC_GL_ARB_stencil_texturing

#define MC_GL_NV_shader_storage_buffer_object

#define MC_GL_ARB_compute_shader

#define MC_GL_ARB_shader_objects

#define MC_GL_NV_gpu_program4_1

#define MC_GL_ARB_multi_draw_indirect

#define MC_GL_ARB_parallel_shader_compile

#define MC_GL_EXT_texture_array

#define MC_GL_ARB_get_texture_sub_image

#define MC_GL_SUN_slice_accum

#define MC_GL_NV_vertex_array_range2

#define MC_GL_NV_gpu_program5_mem_extended

#define MC_GL_EXT_Cg_shader

#define MC_GL_ARB_pixel_buffer_object

#define MC_GL_ARB_tessellation_shader

#define MC_GL_ARB_texture_cube_map_array

#define MC_GL_NV_memory_attachment

#define MC_GL_SGIX_shadow

#define MC_GL_ARB_vertex_array_bgra

#define MC_GL_NV_fragment_coverage_to_color

#define MC_GL_EXT_vertex_attrib_64bit

#define MC_GL_NV_vdpau_interop2

#define MC_GL_NVX_conditional_render

#define MC_GL_NVX_progress_fence

#define MC_GL_EXT_texture_lod_bias

#define MC_GL_EXT_rescale_normal

#define MC_GL_NV_uniform_buffer_unified_memory

#define MC_GL_EXT_memory_object_fd

#define MC_GL_ARB_clear_buffer_object

#define MC_GL_NV_vertex_program1_1

#define MC_GL_NV_query_resource_tag

#define MC_GL_ARB_transform_feedback_instanced

#define MC_GL_ARB_uniform_buffer_object

#define MC_GL_NV_float_buffer

#define MC_GL_KHR_blend_equation_advanced_coherent

#define MC_GL_NV_timeline_semaphore

#define MC_GL_EXT_texture_cube_map

#define MC_GL_ARB_conservative_depth

#define MC_GL_EXT_texture_shared_exponent

#define MC_GL_KHR_robust_buffer_access_behavior

#define MC_GL_IBM_rasterpos_clip

#define MC_GL_ARB_fragment_shader

#define MC_GL_ARB_ES2_compatibility

#define MC_GL_ARB_direct_state_access

#define MC_GL_ARB_draw_instanced

#define MC_GL_EXT_shader_image_load_store

#define MC_GL_ARB_gpu_shader_fp64

#define MC_GL_ARB_texture_buffer_object

#define MC_GL_NV_sample_mask_override_coverage

#define MC_GL_ARB_instanced_arrays

#define MC_GL_ARB_sync

#define MC_GL_ARB_sample_locations

#define MC_GL_NV_point_sprite

#define MC_GL_ARB_base_instance

#define MC_GL_ARB_texture_compression

#define MC_GL_ARB_gpu_shader5

#define MC_GL_NV_viewport_array2

#define MC_GL_EXT_blend_color

#define MC_GL_EXT_gpu_shader4

#define MC_GL_ARB_texture_query_levels

#define MC_GL_EXT_post_depth_coverage

#define MC_GL_EXT_semaphore_fd

#define MC_GL_ARB_texture_non_power_of_two

#define MC_GL_EXT_draw_buffers2

#define MC_GL_EXT_multi_draw_arrays

#define MC_GL_EXT_vertex_array

#define MC_GL_ARB_texture_filter_minmax

#define MC_GL_ARB_texture_buffer_range

#define MC_GL_ARB_shadow

#define MC_GL_ARB_clip_control

#define MC_GL_ARB_ES3_2_compatibility

#define MC_GL_ARB_shading_language_include

#define MC_GL_ARB_texture_compression_bptc

#define MC_GL_ARB_multisample

#define MC_GL_ARB_point_sprite

#define MC_GL_ARB_fragment_program

#define MC_GL_ARB_vertex_array_object

#define MC_GL_OVR_multiview2

#define MC_GL_EXT_texture_compression_rgtc

#define MC_GL_ARB_multitexture

#define MC_GL_OVR_multiview

#define MC_GL_ARB_clear_texture

#define MC_GL_NV_shader_thread_group

#define MC_GL_ARB_shader_subroutine

#define MC_GL_NV_vdpau_interop

#define MC_GL_ARB_query_buffer_object

#define MC_GL_NV_parameter_buffer_object

#define MC_GL_ARB_ES3_1_compatibility

#define MC_GL_ARB_occlusion_query

#define MC_GL_ARB_draw_indirect

#define MC_GL_ARB_texture_view

#define MC_GL_ARB_internalformat_query

#define MC_GL_NV_draw_vulkan_image

#define MC_GL_NV_query_resource

#define MC_GL_EXT_texture_filter_minmax

#define MC_GL_NV_framebuffer_mixed_samples

#define MC_GL_KHR_robustness

#define MC_GL_EXT_texture_sRGB_decode

#define MC_GL_NVX_gpu_memory_info

#define MC_GL_ARB_shading_language_420pack

#define MC_GL_ATI_texture_mirror_once

#define MC_GL_EXT_texture_lod

#define MC_GL_EXT_framebuffer_sRGB

#define MC_GL_NV_memory_object_sparse

#define MC_GL_NV_texture_env_combine4

#define MC_GL_ARB_texture_multisample

#define MC_GL_ARB_sample_shading

#define MC_GL_ARB_draw_elements_base_vertex

#define MC_GL_EXT_gpu_program_parameters

#define MC_GL_KHR_context_flush_control

#define MC_GL_AMD_seamless_cubemap_per_texture

#define MC_GL_ARB_depth_buffer_float

#define MC_GL_NV_internalformat_sample_query

#define MC_GL_ARB_texture_storage

#define MC_GL_ARB_provoking_vertex

#define MC_GL_ARB_vertex_attrib_binding

#define MC_GL_ARB_texture_env_crossbar

#define MC_GL_ARB_fragment_program_shadow

#define MC_GL_NV_shader_atomic_int64

#define MC_GL_NV_explicit_multisample

#define MC_GL_NV_light_max_exponent

#define MC_GL_ARB_texture_float

#define MC_GL_ARB_texture_storage_multisample

#define MC_GL_ARB_blend_func_extended

#define MC_GL_KTX_buffer_region

#define MC_GL_ARB_fragment_shader_interlock

#define MC_GL_ARB_derivative_control

#define MC_GL_NV_blend_equation_advanced

#define MC_GL_ARB_depth_clamp

#define MC_GL_ARB_shader_atomic_counters

#define MC_GL_EXT_bgra

#define MC_GL_ARB_texture_cube_map

#define MC_GL_ARB_shader_texture_image_samples

#define MC_GL_NV_vertex_array_range

#define MC_GL_ARB_shader_draw_parameters

#define MC_GL_ARB_imaging

#define MC_GL_ARB_texture_mirrored_repeat

#define MC_GL_NV_fragment_program

#define MC_GL_NV_depth_buffer_float

#define MC_GL_EXT_texture_buffer_object

#define MC_GL_SGIX_depth_texture

#define MC_GL_ARB_vertex_type_10f_11f_11f_rev

#define MC_GL_EXT_texture_integer

#define MC_GL_EXT_texture_compression_s3tc

#define MC_GL_KHR_debug

#define MC_GL_ARB_robustness

#define MC_GL_EXT_shader_integer_mix

#define MC_GL_NV_fragment_program2

#define MC_GL_NV_pixel_data_range

#define MC_GL_EXT_timer_query

#define MC_GL_ARB_shader_group_vote

#define MC_GL_ARB_internalformat_query2

#define MC_GL_IBM_texture_mirrored_repeat

#define MC_GL_NV_bindless_multi_draw_indirect_count

#define MC_GL_NV_vertex_program2_option

#define MC_GL_ARB_sampler_objects

#define MC_GL_EXT_stencil_wrap

#define MC_GL_ARB_map_buffer_range

#define MC_GL_EXT_texture_swizzle

#define MC_GL_ARB_program_interface_query

#define MC_GL_ARB_enhanced_layouts

#define MC_GL_ARB_texture_env_combine

#define MC_GL_ARB_post_depth_coverage

#define MC_GL_ATI_texture_float

#define MC_GL_NV_command_list

#define MC_GL_SGIS_generate_mipmap

#define MC_GL_ARB_copy_buffer

#define MC_GL_NV_shader_thread_shuffle

#define MC_GL_NV_depth_clamp

#define MC_GL_AMD_vertex_shader_viewport_index

#define MC_GL_NVX_nvenc_interop

#define MC_GL_ARB_multi_bind

#define MC_GL_SGIS_texture_lod

#define MC_GL_ARB_shader_clock

#define MC_GL_EXT_abgr

#define MC_GL_NV_bindless_texture

#define MC_GL_NV_transform_feedback

#define MC_GL_EXT_stencil_two_side

#define MC_GL_NV_bindless_multi_draw_indirect

#define MC_GL_NV_texture_shader

#define MC_GL_RENDERER_GEFORCE

#define MC_GL_ARB_explicit_attrib_location

#define MC_GL_ARB_gpu_shader_int64

#define MC_GL_NV_gpu_program4

#define MC_GL_EXT_texture_sRGB

#define MC_GL_NV_gpu_program5

#define varying out
#define attribute in
#define gl_Vertex vec4(Position, 1.0)
#define gl_ModelViewProjectionMatrix (gl_ProjectionMatrix * gl_ModelViewMatrix)
#define gl_ModelViewMatrix (iris_ModelViewMat * _iris_internal_translate(iris_ChunkOffset))
#define gl_NormalMatrix mat3(transpose(inverse(gl_ModelViewMatrix)))
#define gl_Normal vec3(0.0, 0.0, 1.0)
#define gl_Color (Color * iris_ColorModulator)
#define gl_MultiTexCoord7  vec4(0.0, 0.0, 0.0, 1.0)
#define gl_MultiTexCoord6  vec4(0.0, 0.0, 0.0, 1.0)
#define gl_MultiTexCoord5  vec4(0.0, 0.0, 0.0, 1.0)
#define gl_MultiTexCoord4  vec4(0.0, 0.0, 0.0, 1.0)
#define gl_MultiTexCoord3  vec4(0.0, 0.0, 0.0, 1.0)
#define gl_MultiTexCoord2  vec4(0.0, 0.0, 0.0, 1.0)
#define gl_MultiTexCoord1 vec4(UV2, 0.0, 1.0)
#define gl_MultiTexCoord0 vec4(UV0, 0.0, 1.0)
#define gl_ProjectionMatrix iris_ProjMat
#define gl_FrontColor iris_FrontColor
#define gl_FogFragCoord iris_FogFragCoord
uniform mat4 iris_LightmapTextureMatrix;
uniform mat4 iris_TextureMat;
uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;

struct iris_FogParameters {
    vec4 color;
    float density;
    float start;
    float end;
    float scale;
};

iris_FogParameters iris_Fog = iris_FogParameters(iris_FogColor, iris_FogDensity, iris_FogStart, iris_FogEnd, 1.0 / (iris_FogEnd - iris_FogStart));

#define gl_Fog iris_Fog
out float iris_FogFragCoord;
vec4 iris_FrontColor;
uniform mat4 iris_ProjMat;
in vec2 UV0;
in ivec2 UV2;
uniform vec4 iris_ColorModulator;
in vec4 Color;
uniform mat4 iris_ModelViewMat;
uniform vec3 iris_ChunkOffset;
mat4 _iris_internal_translate(vec3 offset) {
    // NB: Column-major order
    return mat4(1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                offset.x, offset.y, offset.z, 1.0);
}
in vec3 Position;
vec4 ftransform() { return gl_ModelViewProjectionMatrix * gl_Vertex; }
vec4 texture2D(sampler2D sampler, vec2 coord) { return texture(sampler, coord); }
vec4 texture2DLod(sampler2D sampler, vec2 coord, float lod) { return textureLod(sampler, coord, lod); }
vec4 shadow2D(sampler2DShadow sampler, vec3 coord) { return vec4(texture(sampler, coord)); }
vec4 shadow2DLod(sampler2DShadow sampler, vec3 coord, float lod) { return vec4(textureLod(sampler, coord, lod)); }
#define MC_RENDER_QUALITY 1.0
#define MC_SHADOW_QUALITY 1.0
/*
Sildur's enhanced default, before editing, remember the agreement you've accepted by downloading this shaderpack:
http://www.minecraftforum.net/forums/mapping-and-modding/minecraft-mods/1291396-1-6-4-1-12-1-sildurs-shaders-pc-mac-intel

You are allowed to:
- Modify it for your own personal use only, so don't share it online.

You are not allowed to:
- Rename and/or modify this shaderpack and upload it with your own name on it.
- Provide mirrors by reuploading my shaderpack, if you want to link it, use the link to my thread found above.
- Copy and paste code or even whole files into your "own" shaderpack.
*/
/*--------------------
//ADJUSTABLE VARIABLES//
---------------------*/
#define animationSpeed 1.0  //[0.25 0.5 0.75 1.0 1.25 1.5 1.75 2.0]
#define Waving_Leaves
#define Waving_Vines
#define Waving_Grass
#define Waving_Entities			//Includes: Saplings, small flowers, wheat, carrots, potatoes and beetroot.
#define Waving_Tallgrass
#define Waving_Fire
#define Waving_Lava
#define Waving_Water
#define Waving_Lanterns
#define waves_amplitude 0.65    //[0.55 0.65 0.75 0.85 0.95 1.05 1.15 1.25 1.35 1.45 1.55 1.65 1.75 1.85 1.95 2.05]

//Reflections
#define Reflections				//also adjust in fragment aswell as composite.fsh
#define WaterReflection
#define TransparentReflections	//see block.properties, transparent blocks are assigned to ice (79)

#define Shadows
#define SHADOW_MAP_BIAS 0.80

#define nMap 0					//[0 1 2]0=Off 1=Bumpmapping, 2=Parallax,

//#define TAA
/*---------------------------
//END OF ADJUSTABLE VARIABLES//
----------------------------*/

//Moving entities IDs
//See block.properties for mapped ids
#define ENTITY_SMALLGRASS   10031.0	//
#define ENTITY_LOWERGRASS   10175.0	//lower half only in 1.13+
#define ENTITY_UPPERGRASS	10176.0 //upper half only used in 1.13+
#define ENTITY_SMALLENTS    10059.0	//sapplings(6), dandelion(37), rose(38), carrots(141), potatoes(142), beetroot(207)

#define ENTITY_LEAVES       10018.0	//161 new leaves
#define ENTITY_VINES        10106.0

#define ENTITY_WATER		10008.0	//9
#define ENTITY_LILYPAD      10111.0	//
#define ENTITY_ICE			10079.0	//transparent reflections, stained glass(95, 160), slimeblock(165)

#define ENTITY_FIRE         10051.0	//
#define ENTITY_LAVA   		10010.0	//11
#define ENTITY_EMISSIVE		10089.0 //emissive blocks defined in block.properties
#define ENTITY_WAVING_LANTERN 10090.0

varying vec4 color;
varying vec3 getShadowpos;
varying vec3 vworldpos;
varying mat3 tbnMatrix;
varying vec2 texcoord;
varying vec2 lmcoord;
varying float NdotL;
varying float iswater;
varying float mat;

attribute vec4 mc_Entity;
attribute vec4 mc_midTexCoord;
attribute vec4 at_tangent;                      //xyz = tangent vector, w = handedness, added in 1.7.10

uniform vec3 shadowLightPosition; //this is sun and moon position in eye space, so no need for a day-night switch. Added in 1.8?
uniform vec3 cameraPosition;
uniform mat4 gbufferModelView;
uniform mat4 gbufferModelViewInverse;
uniform mat4 shadowProjection;
uniform mat4 shadowModelView;

//moving stuff
uniform float frameTimeCounter;
const float PI = 3.14;
float pi2wt = (150.79*frameTimeCounter) * animationSpeed;

vec3 calcWave(in vec3 pos, in float fm, in float mm, in float ma, in float f0, in float f1, in float f2, in float f3, in float f4, in float f5) {
	float magnitude = sin(pi2wt*fm + dot(pos, vec3(0.5))) * mm + ma;
	vec3 d012 = sin(vec3(f0, f1, f2)*pi2wt);
	
    vec3 ret;
		 ret.x = pi2wt*f3 + d012.x + d012.y - pos.x + pos.z + pos.y;
		 ret.z = pi2wt*f4 + d012.y + d012.z + pos.x - pos.z + pos.y;
		 ret.y = pi2wt*f5 + d012.z + d012.x + pos.z + pos.y - pos.y;
		 ret = sin(ret)*magnitude;
	
    return ret;
}

vec3 calcMove(in vec3 pos, in float f0, in float f1, in float f2, in float f3, in float f4, in float f5, in vec3 amp1, in vec3 amp2) {
    vec3 move1 = calcWave(pos      , 0.0027, 0.0400, 0.0400, 0.0127, 0.0089, 0.0114, 0.0063, 0.0224, 0.0015) * amp1;
	vec3 move2 = calcWave(pos+move1, 0.0348, 0.0400, 0.0400, f0, f1, f2, f3, f4, f5) * amp2;
    return move1+move2;
}/*---*/

#ifdef Shadows
#define diagonal3(mat) vec3((mat)[0].x, (mat)[1].y, (mat)[2].z)
vec3 calcShadows(in vec3 shadowpos, in vec3 norm){
	shadowpos = mat3(shadowModelView) * shadowpos + shadowModelView[3].xyz;
	shadowpos = diagonal3(shadowProjection) * shadowpos + shadowProjection[3].xyz;

	float distortion = ((1.0 - SHADOW_MAP_BIAS) + length(shadowpos.xy * 1.25) * SHADOW_MAP_BIAS) * 0.85;
	shadowpos.xy /= distortion;
	
	NdotL = clamp(dot(norm, normalize(shadowLightPosition))*1.02-0.02,0.0,1.0);	
	float bias = distortion*distortion*(0.0046*tan(acos(NdotL)));
	
	//Certain things shouldn't be diffused, also adjust bias for cheap self shadowing fix
	if (mc_Entity.x == ENTITY_SMALLGRASS
	|| mc_Entity.x == ENTITY_LOWERGRASS
	|| mc_Entity.x == ENTITY_UPPERGRASS
	|| mc_Entity.x == ENTITY_SMALLENTS
	|| mc_Entity.x == ENTITY_LEAVES
	|| mc_Entity.x == ENTITY_VINES
	|| mc_Entity.x == ENTITY_LILYPAD
	|| mc_Entity.x == ENTITY_FIRE
	|| mc_Entity.x == ENTITY_WAVING_LANTERN	
	|| mc_Entity.x == ENTITY_EMISSIVE	
	|| mc_Entity.x == 10030.0	//cobweb	
	|| mc_Entity.x == 10115.0 //nether wart
	|| mc_Entity.x == 10006.0) {
		NdotL = 0.75;
		bias = 0.0010;
	}
	shadowpos.xyz = shadowpos.xyz * 0.5 + 0.5;
	shadowpos.z -= bias;

	return shadowpos.xyz;
}
#endif

#if nMap == 2
varying float dist;
varying vec3 viewVector;
varying vec4 vtexcoordam; // .st for add, .pq for mul
varying vec2 vtexcoord;
varying float isblock; 	//mc_Entity.x, hack to only apply pom to blocks
#endif

#ifdef TAA
uniform float viewWidth;
uniform float viewHeight;
vec2 texelSize = vec2(1.0/viewWidth,1.0/viewHeight);
uniform int framemod8;
const vec2[8] offsets = vec2[8](vec2(1./8.,-3./8.),
								vec2(-1.,3.)/8.,
								vec2(5.0,1.)/8.,
								vec2(-3,-5.)/8.,
								vec2(-5.,5.)/8.,
								vec2(-7.,-1.)/8.,
								vec2(3,7.)/8.,
								vec2(7.,-7.)/8.);
#endif

void main() {

	//Positioning
	texcoord = (iris_TextureMat * gl_MultiTexCoord0).xy;
	lmcoord = (iris_LightmapTextureMatrix * gl_MultiTexCoord1).xy;	
	vec3 position = mat3(gbufferModelViewInverse) * (gl_ModelViewMatrix * gl_Vertex).xyz + gbufferModelViewInverse[3].xyz;

	vworldpos = position.xyz + cameraPosition;
	bool istopv = gl_MultiTexCoord0.t < mc_midTexCoord.t;

#ifdef Waving_Tallgrass
if (mc_Entity.x == ENTITY_LOWERGRASS && istopv || mc_Entity.x == ENTITY_UPPERGRASS)
			position.xyz += calcMove(vworldpos.xyz,
			0.0041,
			0.0070,
			0.0044,
			0.0038,
			0.0240,
			0.0000,
			vec3(0.8,0.0,0.8),
			vec3(0.4,0.0,0.4));

#endif
if (istopv) {
#ifdef Waving_Grass
	if ( mc_Entity.x == ENTITY_SMALLGRASS)
			position.xyz += calcMove(vworldpos.xyz,
				0.0041,
				0.0070,
				0.0044,
				0.0038,
				0.0063,
				0.0000,
				vec3(3.0,1.6,3.0),
				vec3(0.0,0.0,0.0));
#endif
#ifdef Waving_Entities
	if (mc_Entity.x == ENTITY_SMALLENTS)
			position.xyz += calcMove(vworldpos.xyz,
			0.0041,
			0.0070,
			0.0044,
			0.0038,
			0.0240,
			0.0000,
			vec3(0.8,0.0,0.8),
			vec3(0.4,0.0,0.4));
#endif
#ifdef Waving_Fire
	if ( mc_Entity.x == ENTITY_FIRE)
			position.xyz += calcMove(vworldpos.xyz,
			0.0105,
			0.0096,
			0.0087,
			0.0063,
			0.0097,
			0.0156,
			vec3(1.2,0.4,1.2),
			vec3(0.8,0.8,0.8));
#endif
}

#ifdef Waving_Leaves
	if ( mc_Entity.x == ENTITY_LEAVES)
			position.xyz += calcMove(vworldpos.xyz,
			0.0040,
			0.0064,
			0.0043,
			0.0035,
			0.0037,
			0.0041,
			vec3(1.0,0.2,1.0),
			vec3(0.5,0.1,0.5));
#endif
#ifdef Waving_Vines
	if ( mc_Entity.x == ENTITY_VINES)
			position.xyz += calcMove(vworldpos.xyz,
			0.0040,
			0.0064,
			0.0043,
			0.0035,
			0.0037,
			0.0041,
			vec3(0.5,1.0,0.5),
			vec3(0.25,0.5,0.25));
#endif
#ifdef Waving_Lava
	if(mc_Entity.x == ENTITY_LAVA){
		float fy = fract(vworldpos.y + 0.001);
		float wave = 0.05 * sin(2 * PI * (frameTimeCounter*0.2 + vworldpos.x /  7.0 + vworldpos.z / 13.0))
				   + 0.05 * sin(2 * PI * (frameTimeCounter*0.15 + vworldpos.x / 11.0 + vworldpos.z /  5.0));
		position.y += clamp(wave, -fy, 1.0-fy)*0.5;
	}
#endif
	iswater = 0.0;
	if(mc_Entity.x == ENTITY_WATER)iswater = 0.95;	//don't fully remove shadows on water plane
#ifdef Waving_Water
	if(mc_Entity.x == ENTITY_WATER || mc_Entity.x == ENTITY_LILYPAD) { //water, lilypads
		float fy = fract(vworldpos.y + 0.001);
		float wave = 0.05 * sin(2 * PI * (frameTimeCounter*0.8 + vworldpos.x /  2.5 + vworldpos.z / 5.0))
				   + 0.05 * sin(2 * PI * (frameTimeCounter*0.6 + vworldpos.x / 6.0 + vworldpos.z /  12.0));
		position.y += clamp(wave, -fy, 1.0-fy)*waves_amplitude;
	}
#endif

#ifdef Waving_Lanterns
	if(mc_Entity.x == ENTITY_WAVING_LANTERN){
		vec3 fxyz = fract(vworldpos.xyz + 0.001);
		float wave = 0.025 * sin(2 * PI * (frameTimeCounter*0.4 + vworldpos.x * 0.5 + vworldpos.z * 0.5));
					//+ 0.025 * sin(2 * PI * (frameTimeCounter*0.4 + worldpos.y *0.25 + worldpos.z *0.25));
		float waveY = 0.05 * cos(frameTimeCounter*2.0 + vworldpos.y);
		position.x -= clamp(wave, -fxyz.x, 1.0-fxyz.x);
		position.y += clamp(waveY*0.25, -fxyz.y, 1.0-fxyz.y)+0.015;		
		position.z += clamp(wave*0.45, -fxyz.z, 1.0-fxyz.z);
	}
#endif

mat = 0.0;
#ifdef Reflections
#ifdef WaterReflection
	if(mc_Entity.x == ENTITY_WATER)mat = 1.0;
#endif
#ifdef TransparentReflections
	if(mc_Entity.x == ENTITY_ICE)mat = 2.0; //various ids are mapped to ice in block.properties
#endif
#endif

	gl_Position = gl_ProjectionMatrix * gbufferModelView * vec4(position, 1.0);

#ifdef TAA
	gl_Position.xy += offsets[framemod8] * gl_Position.w*texelSize;
#endif

	//Fog
	gl_FogFragCoord = length(position.xyz);

	color = gl_Color;

	//Fix colors on emissive blocks
	if(mc_Entity.x == ENTITY_EMISSIVE || mc_Entity.x == ENTITY_LAVA || mc_Entity.x == ENTITY_FIRE ||  mc_Entity.x == ENTITY_WAVING_LANTERN || mc_Entity.x == 10300.0)color = vec4(1.0);

	//Bump & Parallax mapping
	vec3 normal = normalize(gl_NormalMatrix * gl_Normal);	
	vec3 tangent = normalize(gl_NormalMatrix * at_tangent.xyz);
	vec3 binormal = normalize(gl_NormalMatrix * cross(at_tangent.xyz, gl_Normal.xyz) * at_tangent.w);
	tbnMatrix = mat3(tangent.x, binormal.x, normal.x,
					 tangent.y, binormal.y, normal.y,
					 tangent.z, binormal.z, normal.z);

#if nMap == 2
	isblock = mc_Entity.x;
	if(mc_Entity.x == ENTITY_EMISSIVE || mc_Entity.x == 10300.0)isblock = -1.0; //enable bump and parallax mapping for defined ids.	
	vec2 midcoord = (iris_TextureMat *  mc_midTexCoord).st;
	vec2 texcoordminusmid = texcoord.xy-midcoord;
	vtexcoordam.pq  = abs(texcoordminusmid)*2;
	vtexcoordam.st  = min(texcoord.xy ,midcoord-texcoordminusmid);
	vtexcoord.xy    = sign(texcoordminusmid)*0.5+0.5;
	
	viewVector = tbnMatrix * (mat3(gl_ModelViewMatrix) * gl_Vertex.xyz + gl_ModelViewMatrix[3].xyz);
	dist = length(gl_ModelViewMatrix * gl_Vertex);
#endif					 
	
#ifdef Shadows
	getShadowpos = calcShadows(position, normal);
#endif
}

